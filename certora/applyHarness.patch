diff -ruN .gitignore .gitignore
--- .gitignore	1969-12-31 16:00:00.000000000 -0800
+++ .gitignore	2022-08-17 08:18:26.000000000 -0700
@@ -0,0 +1,2 @@
+*
+!.gitignore
diff -ruN SwapUtils.sol SwapUtils.sol
--- SwapUtils.sol	2022-08-17 22:05:50.000000000 -0700
+++ SwapUtils.sol	2022-09-07 09:00:48.000000000 -0700
@@ -295,6 +295,10 @@
         }
         revert("Approximation did not converge");
     }
+    
+    function getDApprox(uint256 xp1, uint256 xp2) public pure returns(uint256) {
+        return 0;
+    }
 
     /**
      * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
@@ -309,6 +313,7 @@
         pure
         returns (uint256)
     {
+        return getDApprox(xp[0], xp[1]);
         uint256 numTokens = xp.length;
         uint256 s;
         for (uint256 i = 0; i < numTokens; i++) {
@@ -755,7 +760,45 @@
             v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);
         }
 
-        uint256[] memory newBalances = new uint256[](pooledTokens.length);
+        uint256[] memory newBalances = _addLiquidityHelper1(v, pooledTokens, amounts);
+
+        // invariant after change
+        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);
+        require(v.d1 > v.d0, "D should increase");
+
+        // updated to reflect fees and calculate the user's LP tokens
+        v.d2 = v.d1;
+        uint256[] memory fees = _addLiquidityHelper2(self, v, pooledTokens, newBalances);
+
+        uint256 toMint;
+        if (v.totalSupply == 0) {
+            toMint = v.d1;
+        } else {
+            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);
+        }
+
+        require(toMint >= minToMint, "Couldn't mint min requested");
+
+        // mint the user's LP tokens
+        v.lpToken.mint(msg.sender, toMint);
+
+        emit AddLiquidity(
+            msg.sender,
+            amounts,
+            fees,
+            v.d1,
+            v.totalSupply.add(toMint)
+        );
+
+        return toMint;
+    }
+
+    function _addLiquidityHelper1(
+        ManageLiquidityInfo memory v,
+        IERC20[] memory pooledTokens,
+        uint256[] memory amounts
+    ) internal returns(uint256[] memory newBalances) {
+        newBalances = new uint256[](pooledTokens.length);
 
         for (uint256 i = 0; i < pooledTokens.length; i++) {
             require(
@@ -782,14 +825,16 @@
 
             newBalances[i] = v.balances[i].add(amounts[i]);
         }
+    }
 
-        // invariant after change
-        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);
-        require(v.d1 > v.d0, "D should increase");
-
-        // updated to reflect fees and calculate the user's LP tokens
-        v.d2 = v.d1;
-        uint256[] memory fees = new uint256[](pooledTokens.length);
+    
+    function _addLiquidityHelper2(
+        Swap storage self,
+        ManageLiquidityInfo memory v,
+        IERC20[] memory pooledTokens,
+        uint256[] memory newBalances
+    ) internal returns(uint256[] memory fees) {
+        fees = new uint256[](pooledTokens.length);
 
         if (v.totalSupply != 0) {
             uint256 feePerToken = _feePerToken(
@@ -811,29 +856,8 @@
             // the initial depositor doesn't pay fees
             self.balances = newBalances;
         }
-
-        uint256 toMint;
-        if (v.totalSupply == 0) {
-            toMint = v.d1;
-        } else {
-            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);
-        }
-
-        require(toMint >= minToMint, "Couldn't mint min requested");
-
-        // mint the user's LP tokens
-        v.lpToken.mint(msg.sender, toMint);
-
-        emit AddLiquidity(
-            msg.sender,
-            amounts,
-            fees,
-            v.d1,
-            v.totalSupply.add(toMint)
-        );
-
-        return toMint;
     }
+    
 
     /**
      * @notice Burn LP tokens to remove liquidity from the pool.
@@ -910,9 +934,7 @@
 
         require(dy >= minAmount, "dy < minAmount");
 
-        self.balances[tokenIndex] = self.balances[tokenIndex].sub(
-            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))
-        );
+        self.balances[tokenIndex] = _removeLiquidityOneTokenHelper1(self, dy, dyFee, tokenIndex);
         lpToken.burnFrom(msg.sender, tokenAmount);
         pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);
 
@@ -927,6 +949,12 @@
         return dy;
     }
 
+    function _removeLiquidityOneTokenHelper1(Swap storage self, uint256 dy, uint256 dyFee, uint8 tokenIndex) internal returns(uint256) {
+        self.balances[tokenIndex].sub(
+            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))
+        );
+    }
+
     /**
      * @notice Remove liquidity from the pool, weighted differently than the
      * pool's current balances.
@@ -966,33 +994,11 @@
                 maxBurnAmount != 0,
             ">LP.balanceOf"
         );
+        uint256[] memory fees;
+        uint256 tokenAmount;
 
-        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);
-        uint256[] memory fees = new uint256[](pooledTokens.length);
-        {
-            uint256[] memory balances1 = new uint256[](pooledTokens.length);
-            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);
-            for (uint256 i = 0; i < pooledTokens.length; i++) {
-                balances1[i] = v.balances[i].sub(
-                    amounts[i],
-                    "Cannot withdraw more than available"
-                );
-            }
-            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);
-
-            for (uint256 i = 0; i < pooledTokens.length; i++) {
-                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);
-                uint256 difference = idealBalance.difference(balances1[i]);
-                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);
-                self.balances[i] = balances1[i].sub(
-                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)
-                );
-                balances1[i] = balances1[i].sub(fees[i]);
-            }
-
-            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);
-        }
-        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);
+        (fees, tokenAmount) = _removeLiquidityImbalanceHelper1(self, v, pooledTokens, amounts);
+        
         require(tokenAmount != 0, "Burnt amount cannot be zero");
         tokenAmount = tokenAmount.add(1);
 
@@ -1015,6 +1021,37 @@
         return tokenAmount;
     }
 
+    function _removeLiquidityImbalanceHelper1(
+        Swap storage self,
+        ManageLiquidityInfo memory v,
+        IERC20[] memory pooledTokens,
+        uint256[] memory amounts
+    ) internal returns(uint256[] memory fees, uint256 tokenAmount) {
+        uint256[] memory balances1 = new uint256[](pooledTokens.length);
+        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);
+        v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);
+        for (uint256 i = 0; i < pooledTokens.length; i++) {
+            balances1[i] = v.balances[i].sub(
+                amounts[i],
+                "Cannot withdraw more than available"
+            );
+        }
+        v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);
+
+        for (uint256 i = 0; i < pooledTokens.length; i++) {
+            uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);
+            uint256 difference = idealBalance.difference(balances1[i]);
+            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);
+            self.balances[i] = balances1[i].sub(
+                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)
+            );
+            balances1[i] = balances1[i].sub(fees[i]);
+        }
+
+        v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);
+        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);
+    }
+
     /**
      * @notice withdraw all admin fees to a given address
      * @param self Swap struct to withdraw fees from
diff -ruN registries/PoolRegistry.sol registries/PoolRegistry.sol
--- registries/PoolRegistry.sol	2022-08-05 08:23:59.000000000 -0700
+++ registries/PoolRegistry.sol	2022-08-17 08:18:26.000000000 -0700
@@ -42,8 +42,8 @@
     /// @inheritdoc IPoolRegistry
     mapping(bytes32 => uint256) public override poolsIndexOfNamePlusOne;
 
-    PoolData[] private pools;
-    mapping(uint256 => address[]) private eligiblePairsMap;
+    PoolData[] public pools;                                // MUNGED private => public
+    mapping(uint256 => address[]) internal eligiblePairsMap; // MUNGED private => internal
 
     /**
      * @notice Add a new registry entry to the master list.
@@ -185,7 +185,7 @@
             : _getSwapStorage(inputData.poolAddress).lpToken;
 
         // Check token addresses
-        for (uint8 i = 0; i < 8; i++) {
+        for (uint8 i = 0; i < getConstantLength(); i++) {
             try ISwap(inputData.poolAddress).getToken(i) returns (
                 IERC20 token
             ) {
@@ -561,4 +561,8 @@
                 .div(baseLPTokenTotalSupply);
         }
     }
+
+    function getConstantLength() public view returns (uint256) {
+        return 8; 
+    }
 }