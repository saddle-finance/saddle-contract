{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-4.7.3/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.7.3/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-4.7.3/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/AmplificationUtilsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol\";\nimport \"./SwapUtilsV2.sol\";\n\n/**\n * @title AmplificationUtils library\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtilsV2.Swap` struct.\n * This library assumes the struct is fully validated.\n */\nlibrary AmplificationUtilsV2 {\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n\n    // Constant values used in ramping A calculations\n    uint256 public constant A_PRECISION = 100;\n    uint256 public constant MAX_A = 10**6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function getA(SwapUtilsV2.Swap storage self)\n        external\n        view\n        returns (uint256)\n    {\n        return (_getAPrecise(self) / A_PRECISION);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(SwapUtilsV2.Swap storage self)\n        external\n        view\n        returns (uint256)\n    {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(SwapUtilsV2.Swap storage self)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return a0 + (((a1 - a0) * (block.timestamp - t0)) / (t1 - t0));\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return a0 - (((a0 - a1) * (block.timestamp - t0)) / (t1 - t0));\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(\n        SwapUtilsV2.Swap storage self,\n        uint256 futureA_,\n        uint256 futureTime_\n    ) external {\n        require(\n            block.timestamp >= (self.initialATime + (1 days)),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= (block.timestamp + MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureA_ > 0 && futureA_ < MAX_A,\n            \"futureA_ must be > 0 and < MAX_A\"\n        );\n\n        uint256 initialAPrecise = _getAPrecise(self);\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\n\n        if (futureAPrecise < initialAPrecise) {\n            require(\n                (futureAPrecise * MAX_A_CHANGE) >= initialAPrecise,\n                \"futureA_ is too small\"\n            );\n        } else {\n            require(\n                futureAPrecise <= (initialAPrecise * MAX_A_CHANGE),\n                \"futureA_ is too large\"\n            );\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(\n            initialAPrecise,\n            futureAPrecise,\n            block.timestamp,\n            futureTime_\n        );\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(SwapUtilsV2.Swap storage self) external {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n        uint256 currentA = _getAPrecise(self);\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n}\n"
    },
    "contracts/interfaces/IAllowlistV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAllowlistV1 {\n    function getPoolAccountLimit(address poolAddress)\n        external\n        view\n        returns (uint256);\n\n    function getPoolCap(address poolAddress) external view returns (uint256);\n\n    function verifyAddress(address account, bytes32[] calldata merkleProof)\n        external\n        returns (bool);\n}\n"
    },
    "contracts/interfaces/IMetaSwapDepositV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/ERC20.sol\";\nimport \"./ISwapV2.sol\";\nimport \"./IMetaSwapV1.sol\";\n\ninterface IMetaSwapDepositV1 {\n    function initialize(\n        ISwapV2 _baseSwap,\n        IMetaSwapV1 _metaSwap,\n        IERC20 _metaLPToken\n    ) external;\n}\n"
    },
    "contracts/interfaces/IMetaSwapV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/ERC20.sol\";\nimport \"./ISwapV2.sol\";\n\ninterface IMetaSwapV1 {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function isGuarded() external view returns (bool);\n\n    function metaSwapStorage()\n        external\n        view\n        returns (\n            address baseSwap,\n            uint256 baseVirtualPrice,\n            uint256 baseCacheLastUpdated\n        );\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateSwapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    // state modifying functions\n    function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) external;\n\n    function initializeMetaSwap(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwapV2 baseSwap\n    ) external;\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function swapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISwapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/ERC20.sol\";\nimport \"./IAllowlistV1.sol\";\n\ninterface ISwapV2 {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getAllowlist() external view returns (IAllowlistV1);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function isGuarded() external view returns (bool);\n\n    function paused() external view returns (bool);\n\n    function swapStorage()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address\n        );\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    // state modifying functions\n    function initialize(\n        IERC20[] memory pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 a,\n        uint256 fee,\n        uint256 adminFee,\n        address lpTokenTargetAddress\n    ) external;\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"
    },
    "contracts/LPTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/access/OwnableUpgradeable.sol\";\nimport \"./interfaces/ISwapV2.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user's shares when providing liquidity to swap contracts.\n * @dev Only Swap contracts should initialize and own LPToken contracts.\n */\ncontract LPTokenV2 is ERC20BurnableUpgradeable, OwnableUpgradeable {\n    /**\n     * @notice Initializes this LPToken contract with the given name and symbol\n     * @dev The caller of this function will become the owner. A Swap contract should call this\n     * in its initializer function.\n     * @param name name of this token\n     * @param symbol symbol of this token\n     */\n    function initialize(string memory name, string memory symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(address recipient, uint256 amount) external onlyOwner {\n        require(amount != 0, \"LPToken: cannot mint 0\");\n        _mint(recipient, amount);\n    }\n\n    /**\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\n     * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\n     * This assumes the owner is set to a Swap contract's address.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable) {\n        super._beforeTokenTransfer(from, to, amount);\n        require(to != address(this), \"LPToken: cannot send to itself\");\n    }\n}\n"
    },
    "contracts/MathUtilsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title MathUtils library\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\n * differences between two uint256.\n */\nlibrary MathUtilsV1 {\n    /**\n     * @notice Compares a and b and returns true if the difference between a and b\n     *         is less than 1 or equal to each other.\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return True if the difference between a and b is less than 1 or equal,\n     *         otherwise return false\n     */\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\n        return (difference(a, b) <= 1);\n    }\n\n    /**\n     * @notice Calculates absolute difference between a and b\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return Difference between a and b\n     */\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return a - b;\n        }\n        return b - a;\n    }\n}\n"
    },
    "contracts/meta/MetaSwapDepositV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../LPTokenV2.sol\";\nimport \"../interfaces/ISwapV2.sol\";\nimport \"../interfaces/IMetaSwapV1.sol\";\n\n/**\n * @title MetaSwapDeposit\n * @notice This contract flattens the LP token in a MetaSwap pool for easier user access. MetaSwap must be\n * deployed before this contract can be initialized successfully.\n *\n * For example, suppose there exists a base Swap pool consisting of [DAI, USDC, USDT].\n * Then a MetaSwap pool can be created with [sUSD, BaseSwapLPToken] to allow trades between either\n * the LP token or the underlying tokens and sUSD.\n *\n * MetaSwapDeposit flattens the LP token and remaps them to a single array, allowing users\n * to ignore the dependency on BaseSwapLPToken. Using the above example, MetaSwapDeposit can act\n * as a Swap containing [sUSD, DAI, USDC, USDT] tokens.\n */\ncontract MetaSwapDepositV1 is Initializable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    ISwapV2 public baseSwap;\n    IMetaSwapV1 public metaSwap;\n    IERC20[] public baseTokens;\n    IERC20[] public metaTokens;\n    IERC20[] public tokens;\n    IERC20 public metaLPToken;\n\n    uint256 constant MAX_UINT256 = 2**256 - 1;\n\n    struct RemoveLiquidityImbalanceInfo {\n        ISwapV2 baseSwap;\n        IMetaSwapV1 metaSwap;\n        IERC20 metaLPToken;\n        uint8 baseLPTokenIndex;\n        bool withdrawFromBase;\n        uint256 leftoverMetaLPTokenAmount;\n    }\n\n    /**\n     * @notice Sets the address for the base Swap contract, MetaSwap contract, and the\n     * MetaSwap LP token contract.\n     * @param _baseSwap the address of the base Swap contract\n     * @param _metaSwap the address of the MetaSwap contract\n     * @param _metaLPToken the address of the MetaSwap LP token contract\n     */\n    function initialize(\n        ISwapV2 _baseSwap,\n        IMetaSwapV1 _metaSwap,\n        IERC20 _metaLPToken\n    ) external initializer {\n        __ReentrancyGuard_init();\n        // Check and approve base level tokens to be deposited to the base Swap contract\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try _baseSwap.getToken(i) returns (IERC20 token) {\n                    baseTokens.push(token);\n                    token.safeApprove(address(_baseSwap), MAX_UINT256);\n                    token.safeApprove(address(_metaSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"baseSwap must have at least 2 tokens\");\n        }\n\n        // Check and approve meta level tokens to be deposited to the MetaSwap contract\n        IERC20 baseLPToken;\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try _metaSwap.getToken(i) returns (IERC20 token) {\n                    baseLPToken = token;\n                    metaTokens.push(token);\n                    tokens.push(token);\n                    token.safeApprove(address(_metaSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"metaSwap must have at least 2 tokens\");\n        }\n\n        // Flatten baseTokens and append it to tokens array\n        tokens[tokens.length - 1] = baseTokens[0];\n        for (uint8 i = 1; i < baseTokens.length; i++) {\n            tokens.push(baseTokens[i]);\n        }\n\n        // Approve base Swap LP token to be burned by the base Swap contract for withdrawing\n        baseLPToken.safeApprove(address(_baseSwap), MAX_UINT256);\n        // Approve MetaSwap LP token to be burned by the MetaSwap contract for withdrawing\n        _metaLPToken.safeApprove(address(_metaSwap), MAX_UINT256);\n\n        // Initialize storage variables\n        baseSwap = _baseSwap;\n        metaSwap = _metaSwap;\n        metaLPToken = _metaLPToken;\n    }\n\n    // Mutative functions\n\n    /**\n     * @notice Swap two underlying tokens using the meta pool and the base pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external nonReentrant returns (uint256) {\n        tokens[tokenIndexFrom].safeTransferFrom(msg.sender, address(this), dx);\n        uint256 tokenToAmount = metaSwap.swapUnderlying(\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            minDy,\n            deadline\n        );\n        tokens[tokenIndexTo].safeTransfer(msg.sender, tokenToAmount);\n        return tokenToAmount;\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external nonReentrant returns (uint256) {\n        // Read to memory to save on gas\n        IERC20[] memory memBaseTokens = baseTokens;\n        IERC20[] memory memMetaTokens = metaTokens;\n        uint256 baseLPTokenIndex = memMetaTokens.length - 1;\n\n        require(amounts.length == memBaseTokens.length + baseLPTokenIndex);\n\n        uint256 baseLPTokenAmount;\n        {\n            // Transfer base tokens from the caller and deposit to the base Swap pool\n            uint256[] memory baseAmounts = new uint256[](memBaseTokens.length);\n            bool shouldDepositBaseTokens;\n            for (uint8 i = 0; i < memBaseTokens.length; i++) {\n                IERC20 token = memBaseTokens[i];\n                uint256 depositAmount = amounts[baseLPTokenIndex + i];\n                if (depositAmount > 0) {\n                    token.safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        depositAmount\n                    );\n                    baseAmounts[i] = token.balanceOf(address(this)); // account for any fees on transfer\n                    // if there are any base Swap level tokens, flag it for deposits\n                    shouldDepositBaseTokens = true;\n                }\n            }\n            if (shouldDepositBaseTokens) {\n                // Deposit any base Swap level tokens and receive baseLPToken\n                baseLPTokenAmount = baseSwap.addLiquidity(\n                    baseAmounts,\n                    0,\n                    deadline\n                );\n            }\n        }\n\n        uint256 metaLPTokenAmount;\n        {\n            // Transfer remaining meta level tokens from the caller\n            uint256[] memory metaAmounts = new uint256[](metaTokens.length);\n            for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                IERC20 token = memMetaTokens[i];\n                uint256 depositAmount = amounts[i];\n                if (depositAmount > 0) {\n                    token.safeTransferFrom(\n                        msg.sender,\n                        address(this),\n                        depositAmount\n                    );\n                    metaAmounts[i] = token.balanceOf(address(this)); // account for any fees on transfer\n                }\n            }\n            // Update the baseLPToken amount that will be deposited\n            metaAmounts[baseLPTokenIndex] = baseLPTokenAmount;\n\n            // Deposit the meta level tokens and the baseLPToken\n            metaLPTokenAmount = metaSwap.addLiquidity(\n                metaAmounts,\n                minToMint,\n                deadline\n            );\n        }\n\n        // Transfer the meta lp token to the caller\n        metaLPToken.safeTransfer(msg.sender, metaLPTokenAmount);\n\n        return metaLPTokenAmount;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external nonReentrant returns (uint256[] memory) {\n        IERC20[] memory memBaseTokens = baseTokens;\n        IERC20[] memory memMetaTokens = metaTokens;\n        uint256[] memory totalRemovedAmounts;\n\n        {\n            uint256 numOfAllTokens = memBaseTokens.length +\n                memMetaTokens.length -\n                1;\n            require(minAmounts.length == numOfAllTokens, \"out of range\");\n            totalRemovedAmounts = new uint256[](numOfAllTokens);\n        }\n\n        // Transfer meta lp token from the caller to this\n        metaLPToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 baseLPTokenAmount;\n        {\n            // Remove liquidity from the MetaSwap pool\n            uint256[] memory removedAmounts;\n            uint256 baseLPTokenIndex = memMetaTokens.length - 1;\n            {\n                uint256[] memory metaMinAmounts = new uint256[](\n                    memMetaTokens.length\n                );\n                for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                    metaMinAmounts[i] = minAmounts[i];\n                }\n                removedAmounts = metaSwap.removeLiquidity(\n                    amount,\n                    metaMinAmounts,\n                    deadline\n                );\n            }\n\n            // Send the meta level tokens to the caller\n            for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                totalRemovedAmounts[i] = removedAmounts[i];\n                memMetaTokens[i].safeTransfer(msg.sender, removedAmounts[i]);\n            }\n            baseLPTokenAmount = removedAmounts[baseLPTokenIndex];\n\n            // Remove liquidity from the base Swap pool\n            {\n                uint256[] memory baseMinAmounts = new uint256[](\n                    memBaseTokens.length\n                );\n                for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n                    baseMinAmounts[i] = minAmounts[baseLPTokenIndex + i];\n                }\n                removedAmounts = baseSwap.removeLiquidity(\n                    baseLPTokenAmount,\n                    baseMinAmounts,\n                    deadline\n                );\n            }\n\n            // Send the base level tokens to the caller\n            for (uint8 i = 0; i < memBaseTokens.length; i++) {\n                totalRemovedAmounts[baseLPTokenIndex + i] = removedAmounts[i];\n                memBaseTokens[i].safeTransfer(msg.sender, removedAmounts[i]);\n            }\n        }\n\n        return totalRemovedAmounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external nonReentrant returns (uint256) {\n        uint8 baseLPTokenIndex = uint8(metaTokens.length - 1);\n        uint8 baseTokensLength = uint8(baseTokens.length);\n\n        // Transfer metaLPToken from the caller\n        metaLPToken.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        IERC20 token;\n        if (tokenIndex < baseLPTokenIndex) {\n            // When the desired token is meta level token, we can just call `removeLiquidityOneToken` directly\n            metaSwap.removeLiquidityOneToken(\n                tokenAmount,\n                tokenIndex,\n                minAmount,\n                deadline\n            );\n            token = metaTokens[tokenIndex];\n        } else if (tokenIndex < baseLPTokenIndex + baseTokensLength) {\n            // When the desired token is a base level token, we need to first withdraw via baseLPToken, then withdraw\n            // the desired token from the base Swap contract.\n            uint256 removedBaseLPTokenAmount = metaSwap.removeLiquidityOneToken(\n                tokenAmount,\n                baseLPTokenIndex,\n                0,\n                deadline\n            );\n\n            baseSwap.removeLiquidityOneToken(\n                removedBaseLPTokenAmount,\n                tokenIndex - baseLPTokenIndex,\n                minAmount,\n                deadline\n            );\n            token = baseTokens[tokenIndex - baseLPTokenIndex];\n        } else {\n            revert(\"out of range\");\n        }\n\n        uint256 amountWithdrawn = token.balanceOf(address(this));\n        token.safeTransfer(msg.sender, amountWithdrawn);\n        return amountWithdrawn;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external nonReentrant returns (uint256) {\n        IERC20[] memory memBaseTokens = baseTokens;\n        IERC20[] memory memMetaTokens = metaTokens;\n        uint256[] memory metaAmounts = new uint256[](memMetaTokens.length);\n        uint256[] memory baseAmounts = new uint256[](memBaseTokens.length);\n\n        require(\n            amounts.length == memBaseTokens.length + memMetaTokens.length - 1,\n            \"out of range\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v = RemoveLiquidityImbalanceInfo(\n            baseSwap,\n            metaSwap,\n            metaLPToken,\n            uint8(metaAmounts.length - 1),\n            false,\n            0\n        );\n\n        for (uint8 i = 0; i < v.baseLPTokenIndex; i++) {\n            metaAmounts[i] = amounts[i];\n        }\n\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\n            baseAmounts[i] = amounts[v.baseLPTokenIndex + i];\n            if (baseAmounts[i] > 0) {\n                v.withdrawFromBase = true;\n            }\n        }\n\n        // Calculate how much base LP token we need to get the desired amount of underlying tokens\n        if (v.withdrawFromBase) {\n            metaAmounts[v.baseLPTokenIndex] =\n                (v.baseSwap.calculateTokenAmount(baseAmounts, false) * 10005) /\n                10000;\n        }\n\n        // Transfer MetaSwap LP token from the caller to this contract\n        v.metaLPToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            maxBurnAmount\n        );\n\n        // Withdraw the paired meta level tokens and the base LP token from the MetaSwap pool\n        uint256 burnedMetaLPTokenAmount = v.metaSwap.removeLiquidityImbalance(\n            metaAmounts,\n            maxBurnAmount,\n            deadline\n        );\n        v.leftoverMetaLPTokenAmount = maxBurnAmount - burnedMetaLPTokenAmount;\n\n        // If underlying tokens are desired, withdraw them from the base Swap pool\n        if (v.withdrawFromBase) {\n            v.baseSwap.removeLiquidityImbalance(\n                baseAmounts,\n                metaAmounts[v.baseLPTokenIndex],\n                deadline\n            );\n\n            // Base Swap may require LESS base LP token than the amount we have\n            // In that case, deposit it to the MetaSwap pool.\n            uint256[] memory leftovers = new uint256[](metaAmounts.length);\n            IERC20 baseLPToken = memMetaTokens[v.baseLPTokenIndex];\n            uint256 leftoverBaseLPTokenAmount = baseLPToken.balanceOf(\n                address(this)\n            );\n            if (leftoverBaseLPTokenAmount > 0) {\n                leftovers[v.baseLPTokenIndex] = leftoverBaseLPTokenAmount;\n                v.leftoverMetaLPTokenAmount =\n                    v.leftoverMetaLPTokenAmount +\n                    v.metaSwap.addLiquidity(leftovers, 0, deadline);\n            }\n        }\n\n        // Transfer all withdrawn tokens to the caller\n        for (uint8 i = 0; i < amounts.length; i++) {\n            IERC20 token;\n            if (i < v.baseLPTokenIndex) {\n                token = memMetaTokens[i];\n            } else {\n                token = memBaseTokens[i - v.baseLPTokenIndex];\n            }\n            if (amounts[i] > 0) {\n                token.safeTransfer(msg.sender, amounts[i]);\n            }\n        }\n\n        // If there were any extra meta lp token, transfer them back to the caller as well\n        if (v.leftoverMetaLPTokenAmount > 0) {\n            v.metaLPToken.safeTransfer(msg.sender, v.leftoverMetaLPTokenAmount);\n        }\n\n        return maxBurnAmount - v.leftoverMetaLPTokenAmount;\n    }\n\n    // VIEW FUNCTIONS\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running. When withdrawing from the base pool in imbalanced\n     * fashion, the recommended slippage setting is 0.2% or higher.\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256)\n    {\n        uint256[] memory metaAmounts = new uint256[](metaTokens.length);\n        uint256[] memory baseAmounts = new uint256[](baseTokens.length);\n        uint256 baseLPTokenIndex = metaAmounts.length - 1;\n\n        for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n            metaAmounts[i] = amounts[i];\n        }\n\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\n            baseAmounts[i] = amounts[baseLPTokenIndex + i];\n        }\n\n        uint256 baseLPTokenAmount = baseSwap.calculateTokenAmount(\n            baseAmounts,\n            deposit\n        );\n        metaAmounts[baseLPTokenIndex] = baseLPTokenAmount;\n\n        return metaSwap.calculateTokenAmount(metaAmounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(uint256 amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory metaAmounts = metaSwap.calculateRemoveLiquidity(\n            amount\n        );\n        uint8 baseLPTokenIndex = uint8(metaAmounts.length - 1);\n        uint256[] memory baseAmounts = baseSwap.calculateRemoveLiquidity(\n            metaAmounts[baseLPTokenIndex]\n        );\n\n        uint256[] memory totalAmounts = new uint256[](\n            baseLPTokenIndex + baseAmounts.length\n        );\n        for (uint8 i = 0; i < baseLPTokenIndex; i++) {\n            totalAmounts[i] = metaAmounts[i];\n        }\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\n            totalAmounts[baseLPTokenIndex + i] = baseAmounts[i];\n        }\n\n        return totalAmounts;\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256) {\n        uint8 baseLPTokenIndex = uint8(metaTokens.length - 1);\n\n        if (tokenIndex < baseLPTokenIndex) {\n            return\n                metaSwap.calculateRemoveLiquidityOneToken(\n                    tokenAmount,\n                    tokenIndex\n                );\n        } else {\n            uint256 baseLPTokenAmount = metaSwap\n                .calculateRemoveLiquidityOneToken(\n                    tokenAmount,\n                    baseLPTokenIndex\n                );\n            return\n                baseSwap.calculateRemoveLiquidityOneToken(\n                    baseLPTokenAmount,\n                    tokenIndex - baseLPTokenIndex\n                );\n        }\n    }\n\n    /**\n     * @notice Returns the address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * This is a flattened representation of the pooled tokens.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) external view returns (IERC20) {\n        require(index < tokens.length, \"index out of range\");\n        return tokens[index];\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        return\n            metaSwap.calculateSwapUnderlying(tokenIndexFrom, tokenIndexTo, dx);\n    }\n}\n"
    },
    "contracts/meta/MetaSwapUtilsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol\";\nimport \"../LPTokenV2.sol\";\nimport \"../interfaces/ISwapV2.sol\";\nimport \"../MathUtilsV1.sol\";\nimport \"../SwapUtilsV2.sol\";\n\n/**\n * @title MetaSwapUtils library\n * @notice A library to be used within MetaSwap.sol. Contains functions responsible for custody and AMM functionalities.\n *\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT]. Then a MetaSwap pool can be created\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\n *\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary MetaSwapUtilsV1 {\n    using SafeERC20 for IERC20;\n    using MathUtilsV1 for uint256;\n    using AmplificationUtilsV2 for SwapUtilsV2.Swap;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event TokenSwapUnderlying(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n\n    struct MetaSwap {\n        // Meta-Swap related parameters\n        ISwapV2 baseSwap;\n        uint256 baseVirtualPrice;\n        uint256 baseCacheLastUpdated;\n        IERC20[] baseTokens;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n        uint256 xpi;\n    }\n\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\n    // to avoid stack too deep error\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        LPTokenV2 lpToken;\n        uint256 totalSupply;\n        uint256 preciseA;\n        uint256 baseVirtualPrice;\n        uint256[] tokenPrecisionMultipliers;\n        uint256[] newBalances;\n    }\n\n    struct SwapUnderlyingInfo {\n        uint256 x;\n        uint256 dx;\n        uint256 dy;\n        uint256[] tokenPrecisionMultipliers;\n        uint256[] oldBalances;\n        IERC20[] baseTokens;\n        IERC20 tokenFrom;\n        uint8 metaIndexFrom;\n        IERC20 tokenTo;\n        uint8 metaIndexTo;\n        uint256 baseVirtualPrice;\n    }\n\n    struct CalculateSwapUnderlyingInfo {\n        uint256 baseVirtualPrice;\n        ISwapV2 baseSwap;\n        uint8 baseLPTokenIndex;\n        uint8 baseTokensLength;\n        uint8 metaIndexTo;\n        uint256 x;\n        uint256 dy;\n    }\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Cache expire time for the stored value of base Swap's virtual price\n    uint256 public constant BASE_CACHE_EXPIRE_TIME = 10 minutes;\n    uint256 public constant BASE_VIRTUAL_PRICE_PRECISION = 10**18;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    /**\n     * @notice Return the stored value of base Swap's virtual price. If\n     * value was updated past BASE_CACHE_EXPIRE_TIME, then read it directly\n     * from the base Swap contract.\n     * @param metaSwapStorage MetaSwap struct to read from\n     * @return base Swap's virtual price\n     */\n    function _getBaseVirtualPrice(MetaSwap storage metaSwapStorage)\n        internal\n        view\n        returns (uint256)\n    {\n        if (\n            block.timestamp >\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\n        ) {\n            return metaSwapStorage.baseSwap.getVirtualPrice();\n        }\n        return metaSwapStorage.baseVirtualPrice;\n    }\n\n    function _getBaseSwapFee(ISwapV2 baseSwap)\n        internal\n        view\n        returns (uint256 swapFee)\n    {\n        (, , , , swapFee, , ) = baseSwap.swapStorage();\n    }\n\n    /**\n     * @notice Calculate how much the user would receive when withdrawing via single token\n     * @param self Swap struct to read from\n     * @param metaSwapStorage MetaSwap struct to read from\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @return dy the amount of token user will receive\n     */\n    function calculateWithdrawOneToken(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            _getBaseVirtualPrice(metaSwapStorage),\n            self.lpToken.totalSupply()\n        );\n    }\n\n    function _calculateWithdrawOneToken(\n        SwapUtilsV2.Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 baseVirtualPrice,\n        uint256 totalSupply\n    ) internal view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 dySwapFee;\n\n        {\n            uint256 currentY;\n            uint256 newY;\n\n            // Calculate how much to withdraw\n            (dy, newY, currentY) = _calculateWithdrawOneTokenDY(\n                self,\n                tokenIndex,\n                tokenAmount,\n                baseVirtualPrice,\n                totalSupply\n            );\n\n            // Calculate the associated swap fee\n            dySwapFee =\n                ((currentY - newY) /\n                    self.tokenPrecisionMultipliers[tokenIndex]) -\n                dy;\n        }\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @param baseVirtualPrice the virtual price of the base swap's LP token\n     * @return the dy excluding swap fee, the new y after withdrawing one token, and current y\n     */\n    function _calculateWithdrawOneTokenDY(\n        SwapUtilsV2.Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount,\n        uint256 baseVirtualPrice,\n        uint256 totalSupply\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\n        require(tokenIndex < xp.length, \"Token index out of range\");\n\n        CalculateWithdrawOneTokenDYInfo\n            memory v = CalculateWithdrawOneTokenDYInfo(\n                0,\n                0,\n                0,\n                0,\n                self._getAPrecise(),\n                0\n            );\n        v.d0 = SwapUtilsV2.getD(xp, v.preciseA);\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = SwapUtilsV2.getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = SwapUtilsV2._feePerToken(self.swapFee, xp.length);\n        for (uint256 i = 0; i < xp.length; i++) {\n            v.xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] =\n                v.xpi -\n                (((\n                    (i == tokenIndex)\n                        ? (v.xpi * v.d1) / v.d0 - v.newY\n                        : v.xpi - ((v.xpi * v.d1) / v.d0)\n                ) * v.feePerToken) / FEE_DENOMINATOR);\n        }\n\n        uint256 dy = xpReduced[tokenIndex] -\n            SwapUtilsV2.getYD(v.preciseA, tokenIndex, xpReduced, v.d1);\n\n        if (tokenIndex == xp.length - 1) {\n            dy = (dy * BASE_VIRTUAL_PRICE_PRECISION) / baseVirtualPrice;\n            v.newY = (v.newY * BASE_VIRTUAL_PRICE_PRECISION) / baseVirtualPrice;\n            xp[tokenIndex] =\n                (xp[tokenIndex] * BASE_VIRTUAL_PRICE_PRECISION) /\n                baseVirtualPrice;\n        }\n        dy = (dy - 1) / self.tokenPrecisionMultipliers[tokenIndex];\n\n        return (dy, v.newY, xp[tokenIndex]);\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances. The last element will also get scaled up by\n     * the given baseVirtualPrice.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @param baseVirtualPrice the base virtual price to scale the balance of the\n     * base Swap's LP token.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers,\n        uint256 baseVirtualPrice\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory xp = SwapUtilsV2._xp(balances, precisionMultipliers);\n        uint256 baseLPTokenIndex = balances.length - 1;\n        xp[baseLPTokenIndex] =\n            (xp[baseLPTokenIndex] * baseVirtualPrice) /\n            BASE_VIRTUAL_PRICE_PRECISION;\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(SwapUtilsV2.Swap storage self, uint256 baseVirtualPrice)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return\n            _xp(\n                self.balances,\n                self.tokenPrecisionMultipliers,\n                baseVirtualPrice\n            );\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @param metaSwapStorage MetaSwap struct to read from\n     * @return the virtual price, scaled to precision of BASE_VIRTUAL_PRICE_PRECISION\n     */\n    function getVirtualPrice(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage\n    ) external view returns (uint256) {\n        uint256 d = SwapUtilsV2.getD(\n            _xp(\n                self.balances,\n                self.tokenPrecisionMultipliers,\n                _getBaseVirtualPrice(metaSwapStorage)\n            ),\n            self._getAPrecise()\n        );\n        uint256 supply = self.lpToken.totalSupply();\n        if (supply != 0) {\n            return (d * BASE_VIRTUAL_PRICE_PRECISION) / supply;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens. The SwapUtils.Swap storage and\n     * MetaSwap storage should be from the same MetaSwap contract.\n     * @param self Swap struct to read from\n     * @param metaSwapStorage MetaSwap struct from the same contract\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            _getBaseVirtualPrice(metaSwapStorage)\n        );\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param baseVirtualPrice the virtual price of the base LP token\n     * @return dy the number of tokens the user will get and dyFee the associated fee\n     */\n    function _calculateSwap(\n        SwapUtilsV2.Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 baseVirtualPrice\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\n        require(\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n            \"Token index out of range\"\n        );\n        uint256 baseLPTokenIndex = xp.length - 1;\n\n        uint256 x = dx * self.tokenPrecisionMultipliers[tokenIndexFrom];\n        if (tokenIndexFrom == baseLPTokenIndex) {\n            // When swapping from a base Swap token, scale up dx by its virtual price\n            x = (x * baseVirtualPrice) / BASE_VIRTUAL_PRICE_PRECISION;\n        }\n        x = x + xp[tokenIndexFrom];\n\n        uint256 y = SwapUtilsV2.getY(\n            self._getAPrecise(),\n            tokenIndexFrom,\n            tokenIndexTo,\n            x,\n            xp\n        );\n        dy = xp[tokenIndexTo] - y - 1;\n\n        if (tokenIndexTo == baseLPTokenIndex) {\n            // When swapping to a base Swap token, scale down dy by its virtual price\n            dy = (dy * BASE_VIRTUAL_PRICE_PRECISION) / baseVirtualPrice;\n        }\n\n        dyFee = (dy * self.swapFee) / FEE_DENOMINATOR;\n        dy = dy - dyFee;\n\n        dy = dy / self.tokenPrecisionMultipliers[tokenIndexTo];\n    }\n\n    /**\n     * @notice Calculates the expected return amount from swapping between\n     * the pooled tokens and the underlying tokens of the base Swap pool.\n     *\n     * @param self Swap struct to read from\n     * @param metaSwapStorage MetaSwap struct from the same contract\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwapUnderlying(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256) {\n        CalculateSwapUnderlyingInfo memory v = CalculateSwapUnderlyingInfo(\n            _getBaseVirtualPrice(metaSwapStorage),\n            metaSwapStorage.baseSwap,\n            0,\n            uint8(metaSwapStorage.baseTokens.length),\n            0,\n            0,\n            0\n        );\n\n        uint256[] memory xp = _xp(self, v.baseVirtualPrice);\n        v.baseLPTokenIndex = uint8(xp.length - 1);\n        {\n            uint8 maxRange = v.baseLPTokenIndex + v.baseTokensLength;\n            require(\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\n                \"Token index out of range\"\n            );\n        }\n\n        if (tokenIndexFrom < v.baseLPTokenIndex) {\n            // tokenFrom is from this pool\n            v.x =\n                xp[tokenIndexFrom] +\n                (dx * self.tokenPrecisionMultipliers[tokenIndexFrom]);\n        } else {\n            // tokenFrom is from the base pool\n            tokenIndexFrom = tokenIndexFrom - v.baseLPTokenIndex;\n            if (tokenIndexTo < v.baseLPTokenIndex) {\n                uint256[] memory baseInputs = new uint256[](v.baseTokensLength);\n                baseInputs[tokenIndexFrom] = dx;\n                v.x =\n                    (v.baseSwap.calculateTokenAmount(baseInputs, true) *\n                        v.baseVirtualPrice) /\n                    BASE_VIRTUAL_PRICE_PRECISION;\n                // when adding to the base pool,you pay approx 50% of the swap fee\n                v.x =\n                    v.x -\n                    ((v.x * _getBaseSwapFee(metaSwapStorage.baseSwap)) /\n                        (FEE_DENOMINATOR * 2)) +\n                    xp[v.baseLPTokenIndex];\n            } else {\n                // both from and to are from the base pool\n                return\n                    v.baseSwap.calculateSwap(\n                        tokenIndexFrom,\n                        tokenIndexTo - v.baseLPTokenIndex,\n                        dx\n                    );\n            }\n            tokenIndexFrom = v.baseLPTokenIndex;\n        }\n\n        v.metaIndexTo = v.baseLPTokenIndex;\n        if (tokenIndexTo < v.baseLPTokenIndex) {\n            v.metaIndexTo = tokenIndexTo;\n        }\n\n        {\n            uint256 y = SwapUtilsV2.getY(\n                self._getAPrecise(),\n                tokenIndexFrom,\n                v.metaIndexTo,\n                v.x,\n                xp\n            );\n            v.dy = xp[v.metaIndexTo] - y - 1;\n            uint256 dyFee = (v.dy * self.swapFee) / FEE_DENOMINATOR;\n            v.dy = v.dy - dyFee;\n        }\n\n        if (tokenIndexTo < v.baseLPTokenIndex) {\n            // tokenTo is from this pool\n            v.dy = v.dy / self.tokenPrecisionMultipliers[v.metaIndexTo];\n        } else {\n            // tokenTo is from the base pool\n            v.dy = v.baseSwap.calculateRemoveLiquidityOneToken(\n                (v.dy * BASE_VIRTUAL_PRICE_PRECISION) / v.baseVirtualPrice,\n                tokenIndexTo - v.baseLPTokenIndex\n            );\n        }\n\n        return v.dy;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param metaSwapStorage MetaSwap struct to read from\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 a = self._getAPrecise();\n        uint256 d0;\n        uint256 d1;\n        {\n            uint256 baseVirtualPrice = _getBaseVirtualPrice(metaSwapStorage);\n            uint256[] memory balances1 = self.balances;\n            uint256[] memory tokenPrecisionMultipliers = self\n                .tokenPrecisionMultipliers;\n            uint256 numTokens = balances1.length;\n            d0 = SwapUtilsV2.getD(\n                _xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),\n                a\n            );\n            for (uint256 i = 0; i < numTokens; i++) {\n                if (deposit) {\n                    balances1[i] = balances1[i] + amounts[i];\n                } else {\n                    if (amounts[i] > balances1[i]) {\n                        revert(\"Cannot withdraw more than available\");\n                    } else {\n                        unchecked {\n                            balances1[i] = balances1[i] - amounts[i];\n                        }\n                    }\n                }\n            }\n            d1 = SwapUtilsV2.getD(\n                _xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),\n                a\n            );\n        }\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return ((d1 - d0) * totalSupply) / d0;\n        } else {\n            return ((d0 - d1) * totalSupply) / d0;\n        }\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param metaSwapStorage MetaSwap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swap(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        {\n            uint256 pooledTokensLength = self.pooledTokens.length;\n            require(\n                tokenIndexFrom < pooledTokensLength &&\n                    tokenIndexTo < pooledTokensLength,\n                \"Token index is out of range\"\n            );\n        }\n\n        uint256 transferredDx;\n        {\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n            require(\n                dx <= tokenFrom.balanceOf(msg.sender),\n                \"Cannot swap more than you own\"\n            );\n\n            {\n                // Transfer tokens first to see if a fee was charged on transfer\n                uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n                tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n                // Use the actual transferred amount for AMM math\n                transferredDx =\n                    tokenFrom.balanceOf(address(this)) -\n                    beforeBalance;\n            }\n        }\n\n        (uint256 dy, uint256 dyFee) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            transferredDx,\n            _updateBaseVirtualPrice(metaSwapStorage)\n        );\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee = (dyFee * self.adminFee) /\n            FEE_DENOMINATOR /\n            self.tokenPrecisionMultipliers[tokenIndexTo];\n\n        self.balances[tokenIndexFrom] =\n            self.balances[tokenIndexFrom] +\n            transferredDx;\n        self.balances[tokenIndexTo] =\n            self.balances[tokenIndexTo] -\n            dy -\n            dyAdminFee;\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n        emit TokenSwap(\n            msg.sender,\n            transferredDx,\n            dy,\n            tokenIndexFrom,\n            tokenIndexTo\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Swaps with the underlying tokens of the base Swap pool. For this function,\n     * the token indices are flattened out so that underlying tokens are represented\n     * in the indices.\n     * @dev Since this calls multiple external functions during the execution,\n     * it is recommended to protect any function that depends on this with reentrancy guards.\n     * @param self Swap struct to read from and write to\n     * @param metaSwapStorage MetaSwap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swapUnderlying(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        SwapUnderlyingInfo memory v = SwapUnderlyingInfo(\n            0,\n            0,\n            0,\n            self.tokenPrecisionMultipliers,\n            self.balances,\n            metaSwapStorage.baseTokens,\n            IERC20(address(0)),\n            0,\n            IERC20(address(0)),\n            0,\n            _updateBaseVirtualPrice(metaSwapStorage)\n        );\n\n        uint8 baseLPTokenIndex = uint8(v.oldBalances.length - 1);\n\n        {\n            uint8 maxRange = uint8(baseLPTokenIndex + v.baseTokens.length);\n            require(\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\n                \"Token index out of range\"\n            );\n        }\n\n        ISwapV2 baseSwap = metaSwapStorage.baseSwap;\n\n        // Find the address of the token swapping from and the index in MetaSwap's token list\n        if (tokenIndexFrom < baseLPTokenIndex) {\n            v.tokenFrom = self.pooledTokens[tokenIndexFrom];\n            v.metaIndexFrom = tokenIndexFrom;\n        } else {\n            v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];\n            v.metaIndexFrom = baseLPTokenIndex;\n        }\n\n        // Find the address of the token swapping to and the index in MetaSwap's token list\n        if (tokenIndexTo < baseLPTokenIndex) {\n            v.tokenTo = self.pooledTokens[tokenIndexTo];\n            v.metaIndexTo = tokenIndexTo;\n        } else {\n            v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];\n            v.metaIndexTo = baseLPTokenIndex;\n        }\n\n        // Check for possible fee on transfer\n        v.dx = v.tokenFrom.balanceOf(address(this));\n        v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n        v.dx = v.tokenFrom.balanceOf(address(this)) - v.dx; // update dx in case of fee on transfer\n\n        if (\n            tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex\n        ) {\n            // Either one of the tokens belongs to the MetaSwap tokens list\n            uint256[] memory xp = _xp(\n                v.oldBalances,\n                v.tokenPrecisionMultipliers,\n                v.baseVirtualPrice\n            );\n\n            if (tokenIndexFrom < baseLPTokenIndex) {\n                // Swapping from a MetaSwap token\n                v.x =\n                    xp[tokenIndexFrom] +\n                    (dx * v.tokenPrecisionMultipliers[tokenIndexFrom]);\n            } else {\n                // Swapping from one of the tokens hosted in the base Swap\n                // This case requires adding the underlying token to the base Swap, then\n                // using the base LP token to swap to the desired token\n                uint256[] memory baseAmounts = new uint256[](\n                    v.baseTokens.length\n                );\n                baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;\n\n                // Add liquidity to the base Swap contract and receive base LP token\n                v.dx = baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);\n\n                // Calculate the value of total amount of baseLPToken we end up with\n                v.x =\n                    ((v.dx * v.baseVirtualPrice) /\n                        BASE_VIRTUAL_PRICE_PRECISION) +\n                    xp[baseLPTokenIndex];\n            }\n\n            // Calculate how much to withdraw in MetaSwap level and the the associated swap fee\n            uint256 dyFee;\n            {\n                uint256 y = SwapUtilsV2.getY(\n                    self._getAPrecise(),\n                    v.metaIndexFrom,\n                    v.metaIndexTo,\n                    v.x,\n                    xp\n                );\n                v.dy = xp[v.metaIndexTo] - y - 1;\n                if (tokenIndexTo >= baseLPTokenIndex) {\n                    // When swapping to a base Swap token, scale down dy by its virtual price\n                    v.dy =\n                        (v.dy * BASE_VIRTUAL_PRICE_PRECISION) /\n                        v.baseVirtualPrice;\n                }\n                dyFee = (v.dy * self.swapFee) / FEE_DENOMINATOR;\n                v.dy =\n                    (v.dy - dyFee) /\n                    v.tokenPrecisionMultipliers[v.metaIndexTo];\n            }\n\n            // Update the balances array according to the calculated input and output amount\n            {\n                uint256 dyAdminFee = (dyFee * self.adminFee) / FEE_DENOMINATOR;\n                dyAdminFee =\n                    dyAdminFee /\n                    v.tokenPrecisionMultipliers[v.metaIndexTo];\n                self.balances[v.metaIndexFrom] =\n                    v.oldBalances[v.metaIndexFrom] +\n                    v.dx;\n                self.balances[v.metaIndexTo] =\n                    v.oldBalances[v.metaIndexTo] -\n                    v.dy -\n                    dyAdminFee;\n            }\n\n            if (tokenIndexTo >= baseLPTokenIndex) {\n                // When swapping to a token that belongs to the base Swap, burn the LP token\n                // and withdraw the desired token from the base pool\n                uint256 oldBalance = v.tokenTo.balanceOf(address(this));\n                baseSwap.removeLiquidityOneToken(\n                    v.dy,\n                    tokenIndexTo - baseLPTokenIndex,\n                    0,\n                    block.timestamp\n                );\n                v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;\n            }\n\n            // Check the amount of token to send meets minDy\n            require(v.dy >= minDy, \"Swap didn't result in min tokens\");\n        } else {\n            // Both tokens are from the base Swap pool\n            // Do a swap through the base Swap\n            v.dy = v.tokenTo.balanceOf(address(this));\n            baseSwap.swap(\n                tokenIndexFrom - baseLPTokenIndex,\n                tokenIndexTo - baseLPTokenIndex,\n                v.dx,\n                minDy,\n                block.timestamp\n            );\n            v.dy = v.tokenTo.balanceOf(address(this)) - v.dy;\n        }\n\n        // Send the desired token to the caller\n        v.tokenTo.safeTransfer(msg.sender, v.dy);\n\n        emit TokenSwapUnderlying(\n            msg.sender,\n            dx,\n            v.dy,\n            tokenIndexFrom,\n            tokenIndexTo\n        );\n\n        return v.dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param metaSwapStorage MetaSwap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] memory amounts,\n        uint256 minToMint\n    ) external returns (uint256) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts must match pooled tokens\"\n        );\n\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n\n        // current state\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            self.lpToken,\n            0,\n            self._getAPrecise(),\n            _updateBaseVirtualPrice(metaSwapStorage),\n            self.tokenPrecisionMultipliers,\n            self.balances\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        if (v.totalSupply != 0) {\n            v.d0 = SwapUtilsV2.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n        }\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            require(\n                v.totalSupply != 0 || amounts[i] > 0,\n                \"Must supply all tokens in pool\"\n            );\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\n                    address(this)\n                );\n                pooledTokens[i].safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amounts[i]\n                );\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] =\n                    pooledTokens[i].balanceOf(address(this)) -\n                    beforeBalance;\n            }\n\n            v.newBalances[i] = v.newBalances[i] + amounts[i];\n        }\n\n        // invariant after change\n        v.d1 = SwapUtilsV2.getD(\n            _xp(v.newBalances, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n            v.preciseA\n        );\n        require(v.d1 > v.d0, \"D should increase\");\n\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        uint256 toMint;\n\n        if (v.totalSupply != 0) {\n            uint256 feePerToken = SwapUtilsV2._feePerToken(\n                self.swapFee,\n                pooledTokens.length\n            );\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = (v.d1 * self.balances[i]) / v.d0;\n                fees[i] =\n                    (feePerToken *\n                        (idealBalance.difference(v.newBalances[i]))) /\n                    FEE_DENOMINATOR;\n                self.balances[i] =\n                    v.newBalances[i] -\n                    ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                v.newBalances[i] = v.newBalances[i] - fees[i];\n            }\n            v.d2 = SwapUtilsV2.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = v.newBalances;\n            toMint = v.d1;\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        self.lpToken.mint(msg.sender, toMint);\n\n        emit AddLiquidity(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply + toMint\n        );\n\n        return toMint;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param metaSwapStorage MetaSwap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount\n    ) external returns (uint256) {\n        LPTokenV2 lpToken = self.lpToken;\n        uint256 totalSupply = lpToken.totalSupply();\n        uint256 numTokens = self.pooledTokens.length;\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 dyFee;\n        uint256 dy;\n\n        (dy, dyFee) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            _updateBaseVirtualPrice(metaSwapStorage),\n            totalSupply\n        );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        // Update balances array\n        self.balances[tokenIndex] =\n            self.balances[tokenIndex] -\n            (dy + ((dyFee * self.adminFee) / FEE_DENOMINATOR));\n\n        // Burn the associated LP token from the caller and send the desired token\n        lpToken.burnFrom(msg.sender, tokenAmount);\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(\n            msg.sender,\n            tokenAmount,\n            totalSupply,\n            tokenIndex,\n            dy\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param metaSwapStorage MetaSwap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        SwapUtilsV2.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        // Using this struct to avoid stack too deep error\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            self.lpToken,\n            0,\n            self._getAPrecise(),\n            _updateBaseVirtualPrice(metaSwapStorage),\n            self.tokenPrecisionMultipliers,\n            self.balances\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        require(\n            amounts.length == v.newBalances.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(maxBurnAmount != 0, \"Must burn more than 0\");\n\n        uint256 feePerToken = SwapUtilsV2._feePerToken(\n            self.swapFee,\n            v.newBalances.length\n        );\n\n        // Calculate how much LPToken should be burned\n        uint256[] memory fees = new uint256[](v.newBalances.length);\n        {\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\n\n            v.d0 = SwapUtilsV2.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                if (amounts[i] > v.newBalances[i]) {\n                    revert(\"Cannot withdraw more than available\");\n                } else {\n                    unchecked {\n                        balances1[i] = v.newBalances[i] - amounts[i];\n                    }\n                }\n            }\n            v.d1 = SwapUtilsV2.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = (v.d1 * v.newBalances[i]) / v.d0;\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = (feePerToken * difference) / FEE_DENOMINATOR;\n                self.balances[i] =\n                    balances1[i] -\n                    ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                balances1[i] = balances1[i] - fees[i];\n            }\n\n            v.d2 = SwapUtilsV2.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n        }\n\n        uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n\n        // Scale up by withdraw fee\n        tokenAmount = tokenAmount + 1;\n\n        // Check for max burn amount\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply - tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice Determines if the stored value of base Swap's virtual price is expired.\n     * If the last update was past the BASE_CACHE_EXPIRE_TIME, then update the stored value.\n     *\n     * @param metaSwapStorage MetaSwap struct to read from and write to\n     * @return base Swap's virtual price\n     */\n    function _updateBaseVirtualPrice(MetaSwap storage metaSwapStorage)\n        internal\n        returns (uint256)\n    {\n        if (\n            block.timestamp >\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\n        ) {\n            // When the cache is expired, update it\n            uint256 baseVirtualPrice = ISwapV2(metaSwapStorage.baseSwap)\n                .getVirtualPrice();\n            metaSwapStorage.baseVirtualPrice = baseVirtualPrice;\n            metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n            return baseVirtualPrice;\n        } else {\n            return metaSwapStorage.baseVirtualPrice;\n        }\n    }\n}\n"
    },
    "contracts/meta/MetaSwapV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../SwapV2.sol\";\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MetaSwapUtilsV1.sol\";\n\n/**\n * @title MetaSwap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT], then a MetaSwap pool can be created\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\n * Note that when interacting with MetaSwap, users cannot deposit or withdraw via underlying tokens. In that case,\n * `MetaSwapDeposit.sol` can be additionally deployed to allow interacting with unwrapped representations of the tokens.\n *\n * @dev Most of the logic is stored as a library `MetaSwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract MetaSwapV1 is SwapV2 {\n    using MetaSwapUtilsV1 for SwapUtilsV2.Swap;\n    using SafeERC20 for IERC20; //TODO: is this needed? wont compile without it\n\n    MetaSwapUtilsV1.MetaSwap public metaSwapStorage;\n\n    uint256 constant MAX_UINT256 = 2**256 - 1;\n\n    /*** EVENTS ***/\n\n    // events replicated from SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwapUnderlying(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice()\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return MetaSwapUtilsV1.getVirtualPrice(swapStorage, metaSwapStorage);\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view virtual override returns (uint256) {\n        return\n            MetaSwapUtilsV1.calculateSwap(\n                swapStorage,\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx\n            );\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap. For this function,\n     * the token indices are flattened out so that underlying tokens are represented.\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view virtual returns (uint256) {\n        return\n            MetaSwapUtilsV1.calculateSwapUnderlying(\n                swapStorage,\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx\n            );\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return\n            MetaSwapUtilsV1.calculateTokenAmount(\n                swapStorage,\n                metaSwapStorage,\n                amounts,\n                deposit\n            );\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view virtual override returns (uint256) {\n        return\n            MetaSwapUtilsV1.calculateWithdrawOneToken(\n                swapStorage,\n                metaSwapStorage,\n                tokenAmount,\n                tokenIndex\n            );\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice This overrides Swap's initialize function to prevent initializing\n     * without the address of the base Swap contract.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     */\n    function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public payable virtual override initializer {\n        revert(\"use initializeMetaSwap() instead\");\n    }\n\n    /**\n     * @notice Initializes this MetaSwap contract with the given parameters.\n     * MetaSwap uses an existing Swap pool to expand the available liquidity.\n     * _pooledTokens array should contain the base Swap pool's LP token as\n     * the last element. For example, if there is a Swap pool consisting of\n     * [DAI, USDC, USDT]. Then a MetaSwap pool can be created with [sUSD, BaseSwapLPToken]\n     * as _pooledTokens.\n     *\n     * This will also deploy the LPToken that represents users'\n     * LP position. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint new tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept. The last\n     * element must be an existing Swap pool's LP token's address.\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     */\n    function initializeMetaSwap(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwapV2 baseSwap\n    ) public payable virtual initializer {\n        __SwapV2_init(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n\n        // MetaSwap initializer\n        metaSwapStorage.baseSwap = baseSwap;\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n\n        // Read all tokens that belong to baseSwap\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try baseSwap.getToken(i) returns (IERC20 token) {\n                    metaSwapStorage.baseTokens.push(token);\n                    token.safeApprove(address(baseSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"baseSwap must pool at least 2 tokens\");\n        }\n\n        // Check the last element of _pooledTokens is owned by baseSwap\n        IERC20 baseLPToken = _pooledTokens[_pooledTokens.length - 1];\n        require(\n            LPTokenV2(address(baseLPToken)).owner() == address(baseSwap),\n            \"baseLPToken is not owned by baseSwap\"\n        );\n\n        // Pre-approve the baseLPToken to be used by baseSwap\n        baseLPToken.safeApprove(address(baseSwap), MAX_UINT256);\n    }\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            MetaSwapUtilsV1.swap(\n                swapStorage,\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx,\n                minDy\n            );\n    }\n\n    /**\n     * @notice Swap two tokens using this pool and the base pool.\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swapUnderlying(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            MetaSwapUtilsV1.swapUnderlying(\n                swapStorage,\n                metaSwapStorage,\n                tokenIndexFrom,\n                tokenIndexTo,\n                dx,\n                minDy\n            );\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            MetaSwapUtilsV1.addLiquidity(\n                swapStorage,\n                metaSwapStorage,\n                amounts,\n                minToMint\n            );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            MetaSwapUtilsV1.removeLiquidityOneToken(\n                swapStorage,\n                metaSwapStorage,\n                tokenAmount,\n                tokenIndex,\n                minAmount\n            );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            MetaSwapUtilsV1.removeLiquidityImbalance(\n                swapStorage,\n                metaSwapStorage,\n                amounts,\n                maxBurnAmount\n            );\n    }\n}\n"
    },
    "contracts/OwnerPausableUpgradeableV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/security/PausableUpgradeable.sol\";\n\n/**\n * @title OwnerPausable\n * @notice An ownable contract allows the owner to pause and unpause the\n * contract without a delay.\n * @dev Only methods using the provided modifiers will be paused.\n */\nabstract contract OwnerPausableUpgradeableV1 is\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    function __OwnerPausable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    /**\n     * @notice Pause the contract. Revert if already paused.\n     */\n    function pause() external onlyOwner {\n        PausableUpgradeable._pause();\n    }\n\n    /**\n     * @notice Unpause the contract. Revert if already unpaused.\n     */\n    function unpause() external onlyOwner {\n        PausableUpgradeable._unpause();\n    }\n}\n"
    },
    "contracts/SwapDeployerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-4.7.3/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-4.7.3/proxy/Clones.sol\";\nimport \"./interfaces/ISwapV2.sol\";\nimport \"./interfaces/IMetaSwapV1.sol\";\n\ncontract SwapDeployerV2 is Ownable {\n    event NewSwapPool(\n        address indexed deployer,\n        address swapAddress,\n        IERC20[] pooledTokens\n    );\n    event NewClone(address indexed target, address cloneAddress);\n\n    constructor() public Ownable() {}\n\n    function clone(address target) external returns (address) {\n        address newClone = _clone(target);\n        emit NewClone(target, newClone);\n\n        return newClone;\n    }\n\n    function _clone(address target) internal returns (address) {\n        return Clones.clone(target);\n    }\n\n    function deploy(\n        address swapAddress,\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) external returns (address) {\n        address swapClone = _clone(swapAddress);\n        ISwapV2(swapClone).initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        Ownable(swapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\n        return swapClone;\n    }\n\n    function deployMetaSwap(\n        address metaSwapAddress,\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwapV2 baseSwap\n    ) external returns (address) {\n        address metaSwapClone = _clone(metaSwapAddress);\n        IMetaSwapV1(metaSwapClone).initializeMetaSwap(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress,\n            baseSwap\n        );\n        Ownable(metaSwapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, metaSwapClone, _pooledTokens);\n        return metaSwapClone;\n    }\n}\n"
    },
    "contracts/SwapUtilsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol\";\nimport \"./AmplificationUtilsV2.sol\";\nimport \"./LPTokenV2.sol\";\nimport \"./MathUtilsV1.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtilsV2 {\n    using SafeERC20 for IERC20;\n    using MathUtilsV1 for uint256;\n\n    /*** EVENTS ***/\n\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n\n    struct Swap {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n        // fee calculation\n        uint256 swapFee;\n        uint256 adminFee;\n        LPTokenV2 lpToken;\n        // contract references for all tokens being pooled\n        IERC20[] pooledTokens;\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n        uint256[] tokenPrecisionMultipliers;\n        // the pool balance of each token, in the token's precision\n        // the contract's actual token balance might differ\n        uint256[] balances;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n    }\n\n    // Struct storing variables used in calculations in the\n    // {add,remove}Liquidity functions to avoid stack too deep errors\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n        LPTokenV2 lpToken;\n        uint256 totalSupply;\n        uint256[] balances;\n        uint256[] multipliers;\n    }\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount * (fee) / (FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 public constant MAX_SWAP_FEE = 10**8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    /*** VIEW & PURE FUNCTIONS ***/\n\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\n        return AmplificationUtilsV2._getAPrecise(self);\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenIndex which token will be withdrawn\n     * @param self Swap struct to read from\n     * @return the amount of token user will receive\n     */\n    function calculateWithdrawOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256) {\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            self.lpToken.totalSupply()\n        );\n        return availableTokenAmount;\n    }\n\n    function _calculateWithdrawOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 totalSupply\n    ) internal view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 newY;\n        uint256 currentY;\n\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\n            self,\n            tokenIndex,\n            tokenAmount,\n            totalSupply\n        );\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n\n        uint256 dySwapFee = ((currentY - newY) /\n            self.tokenPrecisionMultipliers[tokenIndex]) - dy;\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param self Swap struct to read from\n     * @param tokenIndex which token will be withdrawn\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        Swap storage self,\n        uint8 tokenIndex,\n        uint256 tokenAmount,\n        uint256 totalSupply\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256[] memory xp = _xp(self);\n\n        require(tokenIndex < xp.length, \"Token index out of range\");\n\n        CalculateWithdrawOneTokenDYInfo\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(xp, v.preciseA);\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n        uint256[] memory xpReduced = new uint256[](xp.length);\n\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\n        for (uint256 i = 0; i < xp.length; i++) {\n            uint256 xpi = xp[i];\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\n            xpReduced[i] =\n                xpi -\n                (((\n                    (i == tokenIndex)\n                        ? ((xpi * v.d1) / v.d0) - v.newY\n                        : xpi - ((xpi * v.d1) / v.d0)\n                ) * v.feePerToken) / FEE_DENOMINATOR);\n        }\n\n        uint256 dy = xpReduced[tokenIndex] -\n            (getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\n        dy = (dy - 1) / self.tokenPrecisionMultipliers[tokenIndex];\n\n        return (dy, v.newY, xp[tokenIndex]);\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param tokenIndex Index of token we are calculating for.\n     * @param xp a precision-adjusted set of pool balances. Array should be\n     * the same cardinality as the pool.\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(\n        uint256 a,\n        uint8 tokenIndex,\n        uint256[] memory xp,\n        uint256 d\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(tokenIndex < numTokens, \"Token not found\");\n\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = a * (numTokens);\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i != tokenIndex) {\n                s = s + xp[i];\n                c = (c * d) / (xp[i] * (numTokens));\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // c = c * D * D * D * ... overflow!\n            }\n        }\n        c = (c * d * AmplificationUtilsV2.A_PRECISION) / (nA * numTokens);\n\n        uint256 b = s + ((d * AmplificationUtilsV2.A_PRECISION) / nA);\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = ((y * y) + c) / ((y * 2) + b - d);\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n     * as the pool.\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(uint256[] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 numTokens = xp.length;\n        uint256 s;\n        for (uint256 i = 0; i < numTokens; i++) {\n            s = s + xp[i];\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a * numTokens;\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < numTokens; j++) {\n                dP = (dP * d) / (xp[j] * numTokens);\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            d =\n                ((((nA * s) / AmplificationUtilsV2.A_PRECISION) +\n                    (dP * numTokens)) * d) /\n                ((((nA - AmplificationUtilsV2.A_PRECISION) * d) /\n                    AmplificationUtilsV2.A_PRECISION) + ((numTokens + 1) * dP));\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Given a set of balances and precision multipliers, return the\n     * precision-adjusted balances.\n     *\n     * @param balances an array of token balances, in their native precisions.\n     * These should generally correspond with pooled tokens.\n     *\n     * @param precisionMultipliers an array of multipliers, corresponding to\n     * the amounts in the balances array. When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an array of amounts \"scaled\" to the pool's precision\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 numTokens = balances.length;\n        require(\n            numTokens == precisionMultipliers.length,\n            \"Balances must match multipliers\"\n        );\n        uint256[] memory xp = new uint256[](numTokens);\n        for (uint256 i = 0; i < numTokens; i++) {\n            xp[i] = balances[i] * precisionMultipliers[i];\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Return the precision-adjusted balances of all tokens in the pool\n     * @param self Swap struct to read from\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\n     * them to be more easily compared.\n     */\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param self Swap struct to read from\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(Swap storage self)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 d = getD(_xp(self), _getAPrecise(self));\n        LPTokenV2 lpToken = self.lpToken;\n        uint256 supply = lpToken.totalSupply();\n        if (supply > 0) {\n            return (d * (10**uint256(POOL_PRECISION_DECIMALS))) / supply;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given the indexes of the token\n     * that is swapped from (FROM) and the token that is swapped to (TO).\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param preciseA precise form of amplification coefficient\n     * @param tokenIndexFrom index of FROM token\n     * @param tokenIndexTo index of TO token\n     * @param x the new total amount of FROM token\n     * @param xp balances of the tokens in the pool\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        uint256 preciseA,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal pure returns (uint256) {\n        uint256 numTokens = xp.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        uint256 d = getD(xp, preciseA);\n        uint256 c = d;\n        uint256 s;\n        uint256 nA = numTokens * preciseA;\n\n        uint256 _x;\n        for (uint256 i = 0; i < numTokens; i++) {\n            if (i == tokenIndexFrom) {\n                _x = x;\n            } else if (i != tokenIndexTo) {\n                _x = xp[i];\n            } else {\n                continue;\n            }\n            s = s + _x;\n            c = (c * d) / (_x * numTokens);\n            // If we were to protect the division loss we would have to keep the denominator separate\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\n            // c = c * D * D * D * ... overflow!\n        }\n        c = (c * d * AmplificationUtilsV2.A_PRECISION) / (nA * numTokens);\n        uint256 b = s + ((d * AmplificationUtilsV2.A_PRECISION) / nA);\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = (y * y + c) / (y * 2 + b - d);\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            self.balances\n        );\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param self Swap struct to read from\n     * @param tokenIndexFrom the token to sell\n     * @param tokenIndexTo the token to buy\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256[] memory balances\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n        uint256[] memory xp = _xp(balances, multipliers);\n        require(\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n            \"Token index out of range\"\n        );\n        uint256 x = dx * multipliers[tokenIndexFrom] + xp[tokenIndexFrom];\n        uint256 y = getY(\n            _getAPrecise(self),\n            tokenIndexFrom,\n            tokenIndexTo,\n            x,\n            xp\n        );\n        dy = xp[tokenIndexTo] - y - 1;\n        dyFee = (dy * self.swapFee) / FEE_DENOMINATOR;\n        dy = (dy - dyFee) / multipliers[tokenIndexTo];\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @return array of amounts of tokens user will receive\n     */\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return\n            _calculateRemoveLiquidity(\n                self.balances,\n                amount,\n                self.lpToken.totalSupply()\n            );\n    }\n\n    function _calculateRemoveLiquidity(\n        uint256[] memory balances,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (uint256[] memory) {\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n        uint256[] memory amounts = new uint256[](balances.length);\n\n        for (uint256 i = 0; i < balances.length; i++) {\n            amounts[i] = (balances[i] * amount) / totalSupply;\n        }\n        return amounts;\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param self Swap struct to read from\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        Swap storage self,\n        uint256[] calldata amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        uint256 a = _getAPrecise(self);\n        uint256[] memory balances = self.balances;\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n        uint256 d0 = getD(_xp(balances, multipliers), a);\n        for (uint256 i = 0; i < balances.length; i++) {\n            if (deposit) {\n                balances[i] = balances[i] + amounts[i];\n            } else {\n                if (amounts[i] > balances[i]) {\n                    revert(\"Cannot withdraw more than available\");\n                } else {\n                    unchecked {\n                        balances[i] = balances[i] - amounts[i];\n                    }\n                }\n            }\n        }\n        uint256 d1 = getD(_xp(balances, multipliers), a);\n        uint256 totalSupply = self.lpToken.totalSupply();\n\n        if (deposit) {\n            return (((d1 - d0) * totalSupply) / d0);\n        } else {\n            return (((d0 - d1) * totalSupply) / d0);\n        }\n    }\n\n    /**\n     * @notice return accumulated amount of admin fees of the token with given index\n     * @param self Swap struct to read from\n     * @param index Index of the pooled token\n     * @return admin balance in the token's precision\n     */\n    function getAdminBalance(Swap storage self, uint256 index)\n        external\n        view\n        returns (uint256)\n    {\n        require(index < self.pooledTokens.length, \"Token index out of range\");\n        return\n            self.pooledTokens[index].balanceOf(address(this)) -\n            self.balances[index];\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param swapFee swap fee for the tokens\n     * @param numTokens number of tokens pooled\n     */\n    function _feePerToken(uint256 swapFee, uint256 numTokens)\n        internal\n        pure\n        returns (uint256)\n    {\n        return ((swapFee * numTokens) / ((numTokens - 1) * 4));\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param self Swap struct to read from and write to\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @return amount of token user received on swap\n     */\n    function swap(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy\n    ) external returns (uint256) {\n        {\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n            require(\n                dx <= tokenFrom.balanceOf(msg.sender),\n                \"Cannot swap more than you own\"\n            );\n            // Transfer tokens first to see if a fee was charged on transfer\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\n\n            // Use the actual transferred amount for AMM math\n            dx = tokenFrom.balanceOf(address(this)) - beforeBalance;\n        }\n\n        uint256 dy;\n        uint256 dyFee;\n        uint256[] memory balances = self.balances;\n        (dy, dyFee) = _calculateSwap(\n            self,\n            tokenIndexFrom,\n            tokenIndexTo,\n            dx,\n            balances\n        );\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee = (((dyFee * self.adminFee) / FEE_DENOMINATOR) /\n            self.tokenPrecisionMultipliers[tokenIndexTo]);\n\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\n        self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\n\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\n\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n        return dy;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param self Swap struct to read from and write to\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 minToMint\n    ) external returns (uint256) {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts must match pooled tokens\"\n        );\n\n        // current state\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        if (v.totalSupply != 0) {\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n        }\n\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            require(\n                v.totalSupply != 0 || amounts[i] > 0,\n                \"Must supply all tokens in pool\"\n            );\n\n            // Transfer tokens first to see if a fee was charged on transfer\n            if (amounts[i] != 0) {\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\n                    address(this)\n                );\n                pooledTokens[i].safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amounts[i]\n                );\n\n                // Update the amounts[] with actual transfer amount\n                amounts[i] =\n                    pooledTokens[i].balanceOf(address(this)) -\n                    beforeBalance;\n            }\n\n            newBalances[i] = v.balances[i] + amounts[i];\n        }\n        // invariant after change\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n        require(v.d1 > v.d0, \"D should increase\");\n        // updated to reflect fees and calculate the user's LP tokens\n        v.d2 = v.d1;\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n\n        if (v.totalSupply != 0) {\n            uint256 feePerToken = _feePerToken(\n                self.swapFee,\n                pooledTokens.length\n            );\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n                fees[i] =\n                    (feePerToken * idealBalance.difference(newBalances[i])) /\n                    FEE_DENOMINATOR;\n                self.balances[i] =\n                    newBalances[i] -\n                    ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                newBalances[i] = newBalances[i] - fees[i];\n            }\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n        } else {\n            // the initial depositor doesn't pay fees\n            self.balances = newBalances;\n        }\n\n        uint256 toMint;\n        if (v.totalSupply == 0) {\n            toMint = v.d1;\n        } else {\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        v.lpToken.mint(msg.sender, toMint);\n\n        emit AddLiquidity(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply + toMint\n        );\n\n        return toMint;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param self Swap struct to read from and write to\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation\n     * @return amounts of tokens the user received\n     */\n    function removeLiquidity(\n        Swap storage self,\n        uint256 amount,\n        uint256[] calldata minAmounts\n    ) external returns (uint256[] memory) {\n        LPTokenV2 lpToken = self.lpToken;\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(\n            minAmounts.length == pooledTokens.length,\n            \"minAmounts must match poolTokens\"\n        );\n\n        uint256[] memory balances = self.balances;\n        uint256 totalSupply = lpToken.totalSupply();\n\n        uint256[] memory amounts = _calculateRemoveLiquidity(\n            balances,\n            amount,\n            totalSupply\n        );\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n            self.balances[i] = balances[i] - amounts[i];\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        lpToken.burnFrom(msg.sender, amount);\n\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\n\n        return amounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param self Swap struct to read from and write to\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        Swap storage self,\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount\n    ) external returns (uint256) {\n        LPTokenV2 lpToken = self.lpToken;\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\n\n        uint256 totalSupply = lpToken.totalSupply();\n\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\n            self,\n            tokenAmount,\n            tokenIndex,\n            totalSupply\n        );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        self.balances[tokenIndex] =\n            self.balances[tokenIndex] -\n            (dy + ((dyFee * self.adminFee) / FEE_DENOMINATOR));\n        lpToken.burnFrom(msg.sender, tokenAmount);\n        pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\n\n        emit RemoveLiquidityOne(\n            msg.sender,\n            tokenAmount,\n            totalSupply,\n            tokenIndex,\n            dy\n        );\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param self Swap struct to read from and write to\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                if (amounts[i] > v.balances[i]) {\n                    revert(\"Cannot withdraw more than available\");\n                } else {\n                    unchecked {\n                        balances1[i] = v.balances[i] - amounts[i];\n                    }\n                }\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = (feePerToken * difference) / FEE_DENOMINATOR;\n                self.balances[i] =\n                    balances1[i] -\n                    ((fees[i] * self.adminFee) / FEE_DENOMINATOR);\n                balances1[i] = balances1[i] - fees[i];\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount + 1;\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply - tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice withdraw all admin fees to a given address\n     * @param self Swap struct to withdraw fees from\n     * @param to Address to send the fees to\n     */\n    function withdrawAdminFees(Swap storage self, address to) external {\n        IERC20[] memory pooledTokens = self.pooledTokens;\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            IERC20 token = pooledTokens[i];\n            uint256 balance = token.balanceOf(address(this)) - self.balances[i];\n            if (balance != 0) {\n                token.safeTransfer(to, balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * @param self Swap struct to update\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n        self.adminFee = newAdminFee;\n\n        emit NewAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice update the swap fee\n     * @dev fee cannot be higher than 1% of each swap\n     * @param self Swap struct to update\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n        self.swapFee = newSwapFee;\n\n        emit NewSwapFee(newSwapFee);\n    }\n}\n"
    },
    "contracts/SwapV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-4.7.3/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-4.7.3/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable-4.7.3/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./OwnerPausableUpgradeableV1.sol\";\nimport \"./SwapUtilsV2.sol\";\nimport \"./AmplificationUtilsV2.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract SwapV2 is OwnerPausableUpgradeableV1, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    using SwapUtilsV2 for SwapUtilsV2.Swap;\n    using AmplificationUtilsV2 for SwapUtilsV2.Swap;\n\n    // Struct storing data responsible for automatic market maker functionalities. In order to\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\n    SwapUtilsV2.Swap public swapStorage;\n\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n    // getTokenIndex function also relies on this mapping to retrieve token index.\n    mapping(address => uint8) private tokenIndexes;\n\n    /*** EVENTS ***/\n\n    // events replicated from SwapUtils to make the ABI easier for dumb\n    // clients\n    event TokenSwap(\n        address indexed buyer,\n        uint256 tokensSold,\n        uint256 tokensBought,\n        uint128 soldId,\n        uint128 boughtId\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        uint256 boughtId,\n        uint256 tokensBought\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[] tokenAmounts,\n        uint256[] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n    event NewWithdrawFee(uint256 newWithdrawFee);\n    event RampA(\n        uint256 oldA,\n        uint256 newA,\n        uint256 initialTime,\n        uint256 futureTime\n    );\n    event StopRampA(uint256 currentA, uint256 time);\n\n    /**\n     * @notice Initializes this Swap contract with the given parameters.\n     * This will also clone a LPToken contract that represents users'\n     * LP positions. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint/burn tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n     */\n    function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public payable virtual initializer {\n        __SwapV2_init(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n    }\n\n    /**\n     * @notice Initializes this Swap contract with the given parameters.\n     * This will also clone a LPToken contract that represents users'\n     * LP positions. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint/burn tokens.\n     *\n     * @param _pooledTokens an array of ERC20s this pool will accept\n     * @param decimals the decimals to use for each pooled token,\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n     */\n    function __SwapV2_init(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) internal virtual onlyInitializing {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtilsV2.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    (uint256(SwapUtilsV2.POOL_PRECISION_DECIMALS) -\n                        uint256(decimals[i]));\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtilsV2.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtilsV2.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtilsV2.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPTokenV2 lpToken = LPTokenV2(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a * AmplificationUtilsV2.A_PRECISION;\n        swapStorage.futureA = _a * AmplificationUtilsV2.A_PRECISION;\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Deadline not met\");\n        _;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return A parameter\n     */\n    function getA() external view virtual returns (uint256) {\n        return swapStorage.getA();\n    }\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise() external view virtual returns (uint256) {\n        return swapStorage.getAPrecise();\n    }\n\n    /**\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n     * @param index the index of the token\n     * @return address of the token at given index\n     */\n    function getToken(uint8 index) public view virtual returns (IERC20) {\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\n        return swapStorage.pooledTokens[index];\n    }\n\n    /**\n     * @notice Return the index of the given token address. Reverts if no matching\n     * token is found.\n     * @param tokenAddress address of the token\n     * @return the index of the given token address\n     */\n    function getTokenIndex(address tokenAddress)\n        public\n        view\n        virtual\n        returns (uint8)\n    {\n        uint8 index = tokenIndexes[tokenAddress];\n        require(\n            address(getToken(index)) == tokenAddress,\n            \"Token does not exist\"\n        );\n        return index;\n    }\n\n    /**\n     * @notice Return current balance of the pooled token at given index\n     * @param index the index of the token\n     * @return current balance of the pooled token at given index with token's native precision\n     */\n    function getTokenBalance(uint8 index)\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n        return swapStorage.balances[index];\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view virtual returns (uint256) {\n        return swapStorage.getVirtualPrice();\n    }\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param tokenIndexFrom the token the user wants to sell\n     * @param tokenIndexTo the token the user wants to buy\n     * @param dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return amount of tokens the user will receive\n     */\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view virtual returns (uint256) {\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pooledTokens. The amount should be in each\n     * pooled token's native precision. If a token charges a fee on transfers,\n     * use the amount that gets transferred after the fee.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        return swapStorage.calculateTokenAmount(amounts, deposit);\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(uint256 amount)\n        external\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        return swapStorage.calculateRemoveLiquidity(amount);\n    }\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenIndex index of which token will be withdrawn\n     * @return availableTokenAmount calculated amount of underlying token\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view virtual returns (uint256 availableTokenAmount) {\n        return swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\n    }\n\n    /**\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\n     * @param index Index of the pooled token\n     * @return admin's token balance in the token's precision\n     */\n    function getAdminBalance(uint256 index)\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        return swapStorage.getAdminBalance(index);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @param tokenIndexFrom the token the user wants to swap from\n     * @param tokenIndexTo the token the user wants to swap to\n     * @param dx the amount of tokens the user wants to swap from\n     * @param minDy the min amount the user would like to receive, or revert.\n     * @param deadline latest timestamp to accept this transaction\n     */\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n    }\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param amounts the amounts of each token to add, in their native precision\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.addLiquidity(amounts, minToMint);\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     * @param deadline latest timestamp to accept this transaction\n     * @return amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        nonReentrant\n        deadlineCheck(deadline)\n        returns (uint256[] memory)\n    {\n        return swapStorage.removeLiquidity(amount, minAmounts);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param tokenAmount the amount of the token you want to receive\n     * @param tokenIndex the index of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return\n            swapStorage.removeLiquidityOneToken(\n                tokenAmount,\n                tokenIndex,\n                minAmount\n            );\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances. Withdraw fee that decays linearly\n     * over period of 4 weeks since last deposit will apply.\n     * @param amounts how much of each token to withdraw\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param deadline latest timestamp to accept this transaction\n     * @return amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        nonReentrant\n        whenNotPaused\n        deadlineCheck(deadline)\n        returns (uint256)\n    {\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /**\n     * @notice Withdraw all admin fees to the contract owner\n     */\n    function withdrawAdminFees() external payable virtual onlyOwner {\n        swapStorage.withdrawAdminFees(owner());\n    }\n\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(uint256 newAdminFee) external payable onlyOwner {\n        swapStorage.setAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 newSwapFee) external payable onlyOwner {\n        swapStorage.setSwapFee(newSwapFee);\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureTime)\n        external\n        payable\n        onlyOwner\n    {\n        swapStorage.rampA(futureA, futureTime);\n    }\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external payable onlyOwner {\n        swapStorage.stopRampA();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}