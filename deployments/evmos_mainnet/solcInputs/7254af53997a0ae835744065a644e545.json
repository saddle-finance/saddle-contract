{
  "language": "Solidity",
  "sources": {
    "contracts/helper/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls)\n        public\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData)\n    {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (Result[] memory returnData)\n    {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(\n                call.callData\n            );\n            if (requireSuccess)\n                require(result.success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        public\n        payable\n        returns (\n            uint256 blockNumber,\n            bytes32 blockHash,\n            Result[] memory returnData\n        )\n    {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(Call[] calldata calls)\n        public\n        payable\n        returns (\n            uint256 blockNumber,\n            bytes32 blockHash,\n            Result[] memory returnData\n        )\n    {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(\n            true,\n            calls\n        );\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls)\n        public\n        payable\n        returns (Result[] memory returnData)\n    {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(\n                calli.callData\n            );\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(\n                        0x00,\n                        0x08c379a000000000000000000000000000000000000000000000000000000000\n                    )\n                    // set data offset\n                    mstore(\n                        0x04,\n                        0x0000000000000000000000000000000000000000000000000000000000000020\n                    )\n                    // set length of revert string\n                    mstore(\n                        0x24,\n                        0x0000000000000000000000000000000000000000000000000000000000000017\n                    )\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(\n                        0x44,\n                        0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000\n                    )\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls)\n        public\n        payable\n        returns (Result[] memory returnData)\n    {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i = 0; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n            (result.success, result.returnData) = calli.target.call{value: val}(\n                calli.callData\n            );\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(\n                        0x00,\n                        0x08c379a000000000000000000000000000000000000000000000000000000000\n                    )\n                    // set data offset\n                    mstore(\n                        0x04,\n                        0x0000000000000000000000000000000000000000000000000000000000000020\n                    )\n                    // set length of revert string\n                    mstore(\n                        0x24,\n                        0x0000000000000000000000000000000000000000000000000000000000000017\n                    )\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(\n                        0x44,\n                        0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000\n                    )\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber)\n        public\n        view\n        returns (bytes32 blockHash)\n    {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block difficulty\n    function getCurrentBlockDifficulty()\n        public\n        view\n        returns (uint256 difficulty)\n    {\n        difficulty = block.difficulty;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp()\n        public\n        view\n        returns (uint256 timestamp)\n    {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}